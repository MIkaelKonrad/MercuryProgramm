from SpaceCraft import SpaceCraft
from Propulsion import Propulsion
from body1 import Body1
from body2 import Body2
import math
import matplotlib.pyplot as plt
import vectors as vec

class Two_Body_Sys:
    def __init__(self,body1, SpaceCraft,initial_pos,initial_velocity):
        self.center = body1
        self.craft = SpaceCraft
        self.v_0 = initial_pos + initial_velocity
        self.G =  G = 6.67430 * 10**(-11)

    def F(self,t,v):
        dist_sc_E = math.sqrt(v[0]**2 + v[1]**2)
        #below we compute the acceleration generated by the spacecrafts propulsion: [ a_Sc_1, a_Sc_2]
        Sc_const = self.craft.propulsion.delta_m * self.craft.propulsion.I  / (math.sqrt(v[2]**2 + v[3]**2)*self.craft.tim_mass(t))
        a_Sc_1 = v[2] * Sc_const
        a_Sc_2 = v[3] * Sc_const
        # below we compute the acceleration generated by the celestial bodies
        earth_const = self.G * self.center.mass / math.sqrt(v[0]**2 + v[1]**2)**3
        a_E_1 = -v[0] * earth_const
        a_E_2 = -v[1] * earth_const
        return [v[2], v[3] , a_Sc_1 + a_E_1 , a_Sc_2 + a_E_2 ]

    def velocity_estimate(self,t,v_1,v_2):
        d_1= math.sqrt(v_1[0]**2 + v_1[1]**2)
        d_2= math.sqrt(v_2[0]**2 + v_2[1]**2)
        u = vec.Gram_Schmitt(v_1)
        print(u)
        u_d = math.sqrt(u[0]**2 + u[1]**2)
        v=self.G * self.craft.tim_mass(t)* (d_1-d_2)/ (d_1**2 * u_d)
        return v

    def Runge_Kutta(self,h,t_max):
        t = range(0,t_max,h)
        n= len(t)
        sol = []
        sol.append(self.v_0)
    
        for i in range(n-1):
            k_1 = self.F(t[i],sol[i])
            k=0
            kk_2=[]
            for u in sol[i]:
                kk_2.append(u + [0.5*h*j for j in k_1][k] ) 
                k=k+1
            k_2 = self.F(t[i]+h/2, kk_2)
            k=0
            kk_3=[]
            for u in sol[i]:
                kk_3.append(u + [0.5*h*j for j in k_2][k] ) 
                k=k+1
            k_3 = self.F(t[i]+h/2, kk_3)
            k=0
            kk_4=[]
            for u in sol[i]:
                kk_4.append(u + [ 0.5*h*j for j in k_3][k] ) 
                k=k+1
            k_4 = self.F(t[i] + h ,kk_4)
            v_i=[]
            k=0
            for u in sol[i]:
                v_i.append( u + [h*j/6 for j in k_1][k] +  [2*j*h/6 for j in k_2][k] +  [2*j*h/6 for j in k_3][k]  + [h*j/6 for j in k_4][k])
                k = k+1
            sol.append(v_i)
        return sol
    
    def check_estimate(self,t,v_1,v_2):
        v_abs = math.sqrt(v_1[2]**2 +v_1[3]**2)
        v_est = self.velocity_estimate(t,v_1,v_2)
        est = v_abs - v_est
        return est
    
    def check(self,h,t_max):
        sol = self.Runge_Kutta(h,t_max)
        print(self.check_estimate(h*5, sol[5],sol[6]))